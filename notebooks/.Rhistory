arrange(desc(importance))
importance_plot <- ggplot(shap_importance, aes(x = reorder(feature, importance), y = importance)) +
geom_col(fill = "#FF6B6B") +
coord_flip() +
labs(
title = "SHAP Feature Importance",
subtitle = "Mean Absolute SHAP Value",
x = "Feature",
y = "Mean |SHAP Value|"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, face = "bold"),
axis.text = element_text(size = 10)
)
ggsave("shap_importance_bar_r.png", plot = importance_plot, width = 10, height = 8, dpi = 300)
cat("SHAP importance bar plot saved as 'shap_importance_bar_r.png'\n")
} else {
# ==============================================================================
# SHAP VALUES AND PLOTS
# ==============================================================================
cat("\n=== CALCULATING SHAP VALUES ===\n")
# Calculate SHAP values
shap_values <- shap.values(xgb_model = xgb_final, X_train = X_best)
# SHAP summary plot (beeswarm)
cat("Creating SHAP beeswarm plot...\n")
shap_plot <- shap.plot.summary.wrap1(
xgb_final,
X = X_best,
top_n = length(best_model_data$predictors)
)
ggsave("shap_beeswarm_r.png", plot = shap_plot, width = 10, height = 8, dpi = 300)
cat("SHAP beeswarm plot saved as 'shap_beeswarm_r.png'\n")
# SHAP importance plot (bar)
cat("Creating SHAP importance bar plot...\n")
# Calculate mean absolute SHAP values
shap_importance <- data.frame(
feature = colnames(X_best),
importance = colMeans(abs(shap_values$shap_score))
) %>%
arrange(desc(importance))
importance_plot <- ggplot(shap_importance, aes(x = reorder(feature, importance), y = importance)) +
geom_col(fill = "#FF6B6B") +
coord_flip() +
labs(
title = "SHAP Feature Importance",
subtitle = "Mean Absolute SHAP Value",
x = "Feature",
y = "Mean |SHAP Value|"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 14, face = "bold"),
axis.text = element_text(size = 10)
)
ggsave("shap_importance_bar_r.png", plot = importance_plot, width = 10, height = 8, dpi = 300)
cat("SHAP importance bar plot saved as 'shap_importance_bar_r.png'\n")
else {
# ==============================================================================
# FINAL OLS SUMMARY
# ==============================================================================
cat("\n=== FINAL OLS MODEL SUMMARY ===\n")
if (!is.null(best_model_data)) {
cat(sprintf("\nBest Model: %s - %s\n",
best_model_data$regime,
best_model_data$set_name))
cat(sprintf("CV R-squared: %.4f\n", best_r2))
cat("\nRegression Summary:\n")
print(summary(best_model_data$model))
}
# ==============================================================================
# SPATIAL AUTOCORRELATION: MORAN'S I
# ==============================================================================
cat("\n=== MORAN'S I CALCULATION ===\n")
if (!is.null(best_model_data)) {
# Get unique GEOIDs from best model
model_geoids <- unique(best_model_data$df$GEOID)
# Filter tracts to match model data
tracts_model <- tracts %>%
filter(geoid %in% model_geoids)
cat(sprintf("Filtered to %d tracts matching model data\n", nrow(tracts_model)))
# Create spatial weights (Queen contiguity)
tryCatch({
nb <- poly2nb(tracts_model, queen = TRUE)
w <- nb2listw(nb, style = "W", zero.policy = TRUE)
cat(sprintf("Spatial weights created: %d neighbors\n", length(nb)))
# Calculate residuals for best model
residuals_vector <- residuals(best_model_data$model)
# Get corresponding GEOIDs for residuals
model_data_with_resid <- best_model_data$df %>%
mutate(residuals = residuals_vector)
# Merge with tracts to get proper ordering
tracts_with_resid <- tracts_model %>%
left_join(
model_data_with_resid %>% select(GEOID, residuals),
by = c("geoid" = "GEOID")
) %>%
arrange(match(geoid, model_geoids))
# Calculate Moran's I on residuals
moran_test <- moran.test(tracts_with_resid$residuals, w, zero.policy = TRUE)
cat("\n--- Moran's I Test Results (OLS Residuals) ---\n")
cat(sprintf("Moran's I statistic: %.4f\n", moran_test$estimate[1]))
cat(sprintf("Expectation: %.4f\n", moran_test$estimate[2]))
cat(sprintf("Variance: %.6f\n", moran_test$estimate[3]))
cat(sprintf("P-value: %.4e\n", moran_test$p.value))
if (moran_test$p.value < 0.05) {
cat("\n*** Significant spatial autocorrelation detected in residuals ***\n")
cat("Consider using spatial regression models.\n")
} else {
cat("\nNo significant spatial autocorrelation in residuals.\n")
}
}, error = function(e) {
cat(sprintf("Error calculating Moran's I: %s\n", e$message))
w <- NULL
})
}
# ==============================================================================
# SPATIAL ERROR MODEL (SEM)
# ==============================================================================
cat("\n=== SPATIAL ERROR MODEL ===\n")
if (!is.null(best_model_data) && exists("w") && !is.null(w)) {
tryCatch({
# Prepare data for spatial model
# Need to align data with spatial weights order
# Get the order of GEOIDs from the weights object
geoid_order <- attr(w, "region.id")
# Create aligned dataset
df_aligned <- tracts_with_resid %>%
st_drop_geometry() %>%
filter(geoid %in% geoid_order) %>%
arrange(match(geoid, geoid_order))
# Prepare y and X
y_spatial <- df_aligned[[y_col]]
X_spatial <- df_aligned %>%
select(all_of(best_model_data$predictors)) %>%
as.matrix()
# Fit Spatial Error Model
cat("Fitting Spatial Error Model (SEM)...\n")
sem_model <- errorsarlm(
formula = as.formula(paste(y_col, "~", paste(best_model_data$predictors, collapse = " + "))),
data = df_aligned,
listw = w,
zero.policy = TRUE,
method = "eigen"
)
cat("\n--- Spatial Error Model Summary ---\n")
print(summary(sem_model))
# Compare AIC
ols_aic <- AIC(best_model_data$model)
sem_aic <- AIC(sem_model)
cat("\n--- Model Comparison ---\n")
cat(sprintf("OLS AIC: %.2f\n", ols_aic))
cat(sprintf("SEM AIC: %.2f\n", sem_aic))
cat(sprintf("AIC Improvement: %.2f\n", ols_aic - sem_aic))
if (sem_aic < ols_aic) {
cat("\n*** Spatial Error Model provides better fit (lower AIC) ***\n")
}
}, error = function(e) {
cat(sprintf("Error fitting Spatial Error Model: %s\n", e$message))
})
} else {
cat("Skipping Spatial Error Model - spatial weights not available\n")
}
# ==============================================================================
# SCRIPT COMPLETE
# ==============================================================================
cat("\n", rep("=", 78), "\n", sep = "")
cat("ANALYSIS COMPLETE\n")
cat(rep("=", 78), "\n", sep = "")
if (!is.null(best_model_data)) {
cat(sprintf("\nBest Model Summary:\n"))
cat(sprintf("  Regime: %s\n", best_model_data$regime))
cat(sprintf("  Predictor Set: %s\n", best_model_data$set_name))
cat(sprintf("  Number of Predictors: %d\n", length(best_model_data$predictors)))
cat(sprintf("  N Observations: %d\n", nrow(best_model_data$df)))
cat(sprintf("  CV R-squared: %.4f\n", best_r2))
cat(sprintf("  Adj R-squared: %.4f\n", summary(best_model_data$model)$adj.r.squared))
cat("\nOutputs generated:\n")
cat("  - correlation_matrix.png\n")
cat("  - shap_beeswarm.png\n")
cat("  - shap_importance_bar.png\n")
}
cat("\n")
# ==============================================================================
# SPATIAL AUTOCORRELATION: MORAN'S I
# ==============================================================================
cat("\n=== MORAN'S I CALCULATION ===\n")
if (!is.null(best_model_data)) {
# Get unique GEOIDs from best model
model_geoids <- unique(best_model_data$df$GEOID)
# Filter tracts to match model data
tracts_model <- tracts %>%
filter(geoid %in% model_geoids)
cat(sprintf("Filtered to %d tracts matching model data\n", nrow(tracts_model)))
# Create spatial weights (Queen contiguity)
tryCatch({
nb <- poly2nb(tracts_model, queen = TRUE)
w <- nb2listw(nb, style = "W", zero.policy = TRUE)
cat(sprintf("Spatial weights created: %d neighbors\n", length(nb)))
# Calculate residuals for best model
residuals_vector <- residuals(best_model_data$model)
# Get corresponding GEOIDs for residuals
model_data_with_resid <- best_model_data$df %>%
mutate(residuals = residuals_vector)
# Merge with tracts to get proper ordering
tracts_with_resid <- tracts_model %>%
left_join(
model_data_with_resid %>% select(GEOID, residuals),
by = c("geoid" = "GEOID")
) %>%
arrange(match(geoid, model_geoids))
# Calculate Moran's I on residuals
moran_test <- moran.test(tracts_with_resid$residuals, w, zero.policy = TRUE)
cat("\n--- Moran's I Test Results (OLS Residuals) ---\n")
cat(sprintf("Moran's I statistic: %.4f\n", moran_test$estimate[1]))
cat(sprintf("Expectation: %.4f\n", moran_test$estimate[2]))
cat(sprintf("Variance: %.6f\n", moran_test$estimate[3]))
cat(sprintf("P-value: %.4e\n", moran_test$p.value))
if (moran_test$p.value < 0.05) {
cat("\n*** Significant spatial autocorrelation detected in residuals ***\n")
cat("Consider using spatial regression models.\n")
} else {
cat("\nNo significant spatial autocorrelation in residuals.\n")
}
}, error = function(e) {
cat(sprintf("Error calculating Moran's I: %s\n", e$message))
w <- NULL
})
}
# ==============================================================================
# SPATIAL ERROR MODEL (SEM)
# ==============================================================================
cat("\n=== SPATIAL ERROR MODEL ===\n")
if (!is.null(best_model_data) && exists("w") && !is.null(w)) {
tryCatch({
# Prepare data for spatial model
# Need to align data with spatial weights order
# Get the order of GEOIDs from the weights object
geoid_order <- attr(w, "region.id")
# Create aligned dataset
df_aligned <- tracts_with_resid %>%
st_drop_geometry() %>%
filter(geoid %in% geoid_order) %>%
arrange(match(geoid, geoid_order))
# Prepare y and X
y_spatial <- df_aligned[[y_col]]
X_spatial <- df_aligned %>%
select(all_of(best_model_data$predictors)) %>%
as.matrix()
# Fit Spatial Error Model
cat("Fitting Spatial Error Model (SEM)...\n")
sem_model <- errorsarlm(
formula = as.formula(paste(y_col, "~", paste(best_model_data$predictors, collapse = " + "))),
data = df_aligned,
listw = w,
zero.policy = TRUE,
method = "eigen"
)
cat("\n--- Spatial Error Model Summary ---\n")
print(summary(sem_model))
# Compare AIC
ols_aic <- AIC(best_model_data$model)
sem_aic <- AIC(sem_model)
cat("\n--- Model Comparison ---\n")
cat(sprintf("OLS AIC: %.2f\n", ols_aic))
cat(sprintf("SEM AIC: %.2f\n", sem_aic))
cat(sprintf("AIC Improvement: %.2f\n", ols_aic - sem_aic))
if (sem_aic < ols_aic) {
cat("\n*** Spatial Error Model provides better fit (lower AIC) ***\n")
}
}, error = function(e) {
cat(sprintf("Error fitting Spatial Error Model: %s\n", e$message))
})
} else {
cat("Skipping Spatial Error Model - spatial weights not available\n")
}
cat("\n=== SPATIAL ERROR MODEL ===\n")
if (!is.null(best_model_data) && exists("w") && !is.null(w)) {
tryCatch({
# 1. Get the list of GEOIDs and the weights order
geoid_order <- attr(w, "region.id")
# 2. Identify all required columns for the model
required_cols <- c("GEOID", y_col, best_model_data$predictors)
# 3. Create ALIGNED dataset:
#    Start with the data used for OLS (which has all predictors and Y),
#    filter it to match the GEOIDs that have neighbors (in w),
#    and arrange it strictly according to the order of the spatial weights object (w).
df_aligned <- best_model_data$df %>%
select(all_of(required_cols)) %>%
filter(GEOID %in% geoid_order) %>%
arrange(match(GEOID, geoid_order)) %>%
# Rename GEOID column to match standard spatialreg data requirements if necessary,
# but using the actual column name for the join is safer.
rename(geoid = GEOID)
# Check for consistency
if (nrow(df_aligned) != length(geoid_order)) {
stop("Data alignment failed: Number of observations does not match spatial weights order.")
}
# Prepare y and X (No need for X_spatial matrix conversion for errorsarlm)
# The 'errorsarlm' function requires the data frame as input.
# Fit Spatial Error Model
cat("Fitting Spatial Error Model (SEM)...\n")
sem_model <- errorsarlm(
formula = as.formula(paste(y_col, "~", paste(best_model_data$predictors, collapse = " + "))),
data = df_aligned, # Use the correctly aligned data frame
listw = w,
zero.policy = TRUE,
method = "eigen"
)
cat("\n--- Spatial Error Model Summary ---\n")
print(summary(sem_model))
# ... (rest of the code for AIC comparison) ...
}, error = function(e) {
cat(sprintf("Error fitting Spatial Error Model: %s\n", e$message))
})
} else {
cat("Skipping Spatial Error Model - spatial weights not available\n")
}
# ==============================================================================
# SPATIAL AUTOCORRELATION: MORAN'S I
# ==============================================================================
cat("\n=== MORAN'S I CALCULATION ===\n")
if (!is.null(best_model_data)) {
# 1. Get unique GEOIDs from the best OLS model
model_geoids <- unique(best_model_data$df$GEOID)
# 2. Filter the master tracts shapefile to match model data
tracts_model <- tracts %>%
filter(geoid %in% model_geoids)
cat(sprintf("Filtered to %d tracts matching model data\n", nrow(tracts_model)))
# 3. Create spatial weights (Using k=5 KNN to handle disconnected islands)
tryCatch({
# Calculate centroids for the KNN method
coords_model <- st_coordinates(st_centroid(tracts_model))
# Create k=5 nearest neighbor list
nb <- knn2nb(knearneigh(coords_model, k = 5))
w <- nb2listw(nb, style = "W", zero.policy = TRUE)
cat(sprintf("Spatial weights created using k=5 KNN. Regions in list: %d\n", length(nb)))
# 4. Prepare residuals for Moran's I Test
residuals_vector <- residuals(best_model_data$model)
# Get corresponding GEOIDs for residuals
model_data_with_resid <- best_model_data$df %>%
mutate(residuals = residuals_vector)
# Merge with tracts_model to get proper ordering and ensure all tracts are present
# The order of the residuals must match the order of 'w' (which is the order of tracts_model)
tracts_with_resid <- tracts_model %>%
st_drop_geometry() %>% # Drop geometry before join
left_join(
model_data_with_resid %>% select(GEOID, residuals),
by = c("geoid" = "GEOID")
) %>%
# Re-attach geometry from tracts_model only for spatial plotting (if needed later)
left_join(tracts_model %>% select(geoid, geometry), by = "geoid")
# Ensure residuals vector is in the exact order of the weights list ('w')
residuals_aligned <- tracts_with_resid$residuals
# 5. Calculate Moran's I on residuals
moran_test <- moran.test(residuals_aligned, w, zero.policy = TRUE)
cat("\n--- Moran's I Test Results (OLS Residuals) ---\n")
cat(sprintf("Moran's I statistic: %.4f\n", moran_test$estimate[1]))
cat(sprintf("P-value: %.4e\n", moran_test$p.value))
if (moran_test$p.value < 0.05) {
cat("\n*** Significant spatial autocorrelation detected in residuals ***\n")
cat("Proceeding to Spatial Error Model (SEM).\n")
} else {
cat("\nNo significant spatial autocorrelation in residuals.\n")
}
}, error = function(e) {
cat(sprintf("Error creating spatial weights or calculating Moran's I: %s\n", e$message))
w <<- NULL # Ensure 'w' is NULL globally if creation fails
})
}
cat("\n=== SPATIAL ERROR MODEL ===\n")
if (!is.null(best_model_data) && exists("w") && !is.null(w)) {
tryCatch({
# 1. Get the list of GEOIDs and the weights order
geoid_order <- attr(w, "region.id")
# 2. Identify all required columns for the model
required_cols <- c("GEOID", y_col, best_model_data$predictors)
# 3. Create ALIGNED dataset:
#    Start with the data used for OLS (which has all predictors and Y),
#    filter it to match the GEOIDs that have neighbors (in w),
#    and arrange it strictly according to the order of the spatial weights object (w).
df_aligned <- best_model_data$df %>%
select(all_of(required_cols)) %>%
filter(GEOID %in% geoid_order) %>%
arrange(match(GEOID, geoid_order)) %>%
# Rename GEOID column to match standard spatialreg data requirements if necessary,
# but using the actual column name for the join is safer.
rename(geoid = GEOID)
# Check for consistency
if (nrow(df_aligned) != length(geoid_order)) {
stop("Data alignment failed: Number of observations does not match spatial weights order.")
}
# Prepare y and X (No need for X_spatial matrix conversion for errorsarlm)
# The 'errorsarlm' function requires the data frame as input.
# Fit Spatial Error Model
cat("Fitting Spatial Error Model (SEM)...\n")
sem_model <- errorsarlm(
formula = as.formula(paste(y_col, "~", paste(best_model_data$predictors, collapse = " + "))),
data = df_aligned, # Use the correctly aligned data frame
listw = w,
zero.policy = TRUE,
method = "eigen"
)
cat("\n--- Spatial Error Model Summary ---\n")
print(summary(sem_model))
# ... (rest of the code for AIC comparison) ...
}, error = function(e) {
cat(sprintf("Error fitting Spatial Error Model: %s\n", e$message))
})
} else {
cat("Skipping Spatial Error Model - spatial weights not available\n")
}
# ==============================================================================
# SPATIAL AUTOCORRELATION: MORAN'S I
# ==============================================================================
cat("\n=== MORAN'S I CALCULATION ===\n")
if (!is.null(best_model_data)) {
# 1. Get unique GEOIDs from the best OLS model
model_geoids <- unique(best_model_data$df$GEOID)
# 2. Filter the master tracts shapefile to match model data
tracts_model <- tracts %>%
filter(geoid %in% model_geoids)
cat(sprintf("Filtered to %d tracts matching model data\n", nrow(tracts_model)))
# 3. Create spatial weights (Using k=5 KNN to handle disconnected islands)
tryCatch({
# Calculate centroids for the KNN method
coords_model <- st_coordinates(st_centroid(tracts_model))
# Create k=5 nearest neighbor list
nb <- knn2nb(knearneigh(coords_model, k = 5))
w <- nb2listw(nb, style = "W", zero.policy = TRUE)
cat(sprintf("Spatial weights created using k=5 KNN. Regions in list: %d\n", length(nb)))
# 4. Prepare residuals for Moran's I Test
# Create a dataframe of panel residuals (tracts and their residuals)
panel_residuals <- best_model_data$df %>%
mutate(residuals = residuals(best_model_data$model)) %>%
select(GEOID, residuals)
# Aggregate residuals to get ONE value per tract (using the mean)
tract_residuals <- panel_residuals %>%
group_by(GEOID) %>%
summarise(
mean_residual = mean(residuals, na.rm = TRUE),
.groups = 'drop'
)
# Filter tracts_model to ensure correct ordering for the weights (w)
tracts_model_ordered <- tracts_model %>%
st_drop_geometry() %>%
select(geoid) %>%
# Join the aggregated residuals. The order is now determined by tracts_model_ordered.
left_join(tract_residuals, by = c("geoid" = "GEOID")) %>%
# Ensure all values are present and ordered correctly
arrange(match(geoid, attr(w, "region.id")))
# Extract the final, aligned residuals vector
residuals_aligned <- tracts_model_ordered$mean_residual
# 5. Calculate Moran's I on residuals
# The length of residuals_aligned should now be 2321, matching length(w)
moran_test <- moran.test(residuals_aligned, w, zero.policy = TRUE)
cat("\n--- Moran's I Test Results (OLS Residuals) ---\n")
cat(sprintf("Moran's I statistic: %.4f\n", moran_test$estimate[1]))
cat(sprintf("P-value: %.4e\n", moran_test$p.value))
if (moran_test$p.value < 0.05) {
cat("\n*** Significant spatial autocorrelation detected in residuals ***\n")
cat("Proceeding to Spatial Error Model (SEM).\n")
} else {
cat("\nNo significant spatial autocorrelation in residuals.\n")
}
}, error = function(e) {
cat(sprintf("Error creating spatial weights or calculating Moran's I: %s\n", e$message))
w <<- NULL # Ensure 'w' is NULL globally if creation fails
})
}
cat("\n=== SPATIAL ERROR MODEL ===\n")
if (!is.null(best_model_data) && exists("w") && !is.null(w)) {
tryCatch({
# 1. Get the list of GEOIDs and the weights order
geoid_order <- attr(w, "region.id")
# 2. Identify all required columns for the model
required_cols <- c("GEOID", y_col, best_model_data$predictors)
# 3. Create ALIGNED dataset:
#    Start with the data used for OLS (which has all predictors and Y),
#    filter it to match the GEOIDs that have neighbors (in w),
#    and arrange it strictly according to the order of the spatial weights object (w).
df_aligned <- best_model_data$df %>%
select(all_of(required_cols)) %>%
filter(GEOID %in% geoid_order) %>%
arrange(match(GEOID, geoid_order)) %>%
# Rename GEOID column to match standard spatialreg data requirements if necessary,
# but using the actual column name for the join is safer.
rename(geoid = GEOID)
# Check for consistency
if (nrow(df_aligned) != length(geoid_order)) {
stop("Data alignment failed: Number of observations does not match spatial weights order.")
}
# Prepare y and X (No need for X_spatial matrix conversion for errorsarlm)
# The 'errorsarlm' function requires the data frame as input.
# Fit Spatial Error Model
cat("Fitting Spatial Error Model (SEM)...\n")
sem_model <- errorsarlm(
formula = as.formula(paste(y_col, "~", paste(best_model_data$predictors, collapse = " + "))),
data = df_aligned, # Use the correctly aligned data frame
listw = w,
zero.policy = TRUE,
method = "eigen"
)
cat("\n--- Spatial Error Model Summary ---\n")
print(summary(sem_model))
# ... (rest of the code for AIC comparison) ...
}, error = function(e) {
cat(sprintf("Error fitting Spatial Error Model: %s\n", e$message))
})
} else {
cat("Skipping Spatial Error Model - spatial weights not available\n")
}
